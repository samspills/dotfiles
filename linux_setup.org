* Linux Machine Config
:PROPERTIES:
:header-args:shell:  :tangle-mode (identity #o755)
:header-args: :mkdirp yes
:END:
I am attempting to setup a linux machine using an entirely literate config,
manage through org-mode files. My goal is to have several org files, with code
that is tangled to the appropriate locations.

This is still very much a work in progress.

** Git Config
:PROPERTIES:
:ID:       22443b22-e1b4-4e8d-9228-4908aeeccad4
:END:
Set up my user name and email address for git.
#+begin_src yaml :tangle "~/.gitconfig"
[user]
  email = srpillsworth@gmail.com
  name = Sam Pillsworth
#+end_src
** GPG agent configuration
:PROPERTIES:
:ID:       ff9df46b-bcf7-40e8-bbd1-edb3030df298
:END:
I keep my password store encrypted, and I don't want to have to type my master
key every time I need to access a password. I also don't want to store my master
key in any sort of a keychain, partly because I'm paranoid but also partly
because that seems like it would take effort to set up.

Instead I setup a longer cache time for my gpg-agent.

#+begin_src shell :tangle "~/.gnupg/gpg-agent.conf"
allow-emacs-pinentry
allow-loopback-pinentry
max-cache-ttl 10800
default-cache-ttl 10800
log-file /var/log/gpg-agent.log
pinentry-program /usr/bin/pinentry
#+end_src
** Package Installation and Minimal Setup
:PROPERTIES:
:ID:       8b53258b-b348-4001-8782-971aac6402d7
:END:
In order to get my literate config files onto a new machine and run them, I'll
need git and emacs at least. So I figure why not handle package installs before
we get into the org-mode stuff.

I keep the packages I want to install in =packages.txt=:

#+begin_src text :tangle "packages.txt"
community/flameshot
community/light
community/pandoc
community/pass
community/powerline
community/qutebrowser
community/rofi
community/the_silver_searcher
community/tmux
community/xcape
extra/emacs
extra/python-pip
extra/xclip
extra/xorg-xclipboard
#+end_src

I use a bash script to handle the installation and fetching of packages (either
through pacman or by cloning git repositories).
#+begin_src shell :tangle "manjaro_setup.sh" :shebang "#!/usr/bin/env bash"
sudo pacman -Syyu
sudo pacman -Syu --noconfirm $(cat packages.txt | awk '{print $1}')
sudo pacman -Rs $(pacman -Qdtq)

if [ ! -d ~/.password-store ]; then
    echo "setting up password-store"
    git clone git@gitlab.com:samspills/passwords ~/.password-store
    pass init --path=~/.password-store Sam Pillsworth
    pass git init
fi

if [ ! -f ~/.antigen.zsh ]; then
    echo "fetching antigen"
    curl -L git.io/antigen > ~/.antigen.zsh
fi

if [ ! -d ~/dotfiles ]; then
    echo "fetching dotfiles repo"
    git clone git@github.com:samspills/dotfiles /home/sam/dotfiles
    ln -s /home/sam/dotfiles/dot-emacs/.spacemacs /home/sam/.spacemacs
fi

if [ ! -d ~/.emacs.d ]; then
    echo "fetching spacemacs fork"
    git clone git@github.com:samspills/spacemacs ~/.emacs.d
    ln -s /home/sam/dotfiles/dot-emacs/custom.el /home/sam/.emacs.d/custom.el
fi

if [ ! "$SHELL" = "$(which zsh)" ]; then
    chsh -s $(which zsh)
fi

if [ ! -d ~/.etc/rofi-pass ]; then
    echo "fetching rofi-pass"
    git clone git@github.com:carnager/rofi-pass.git ~/.etc/rofi-pass
    ln -s ~/.etc/rofi-pass/rofi-pass ~/bin/rofi-pass
    ln -s ~/.etc/rofi-pass/addpass ~/bin/addpass
fi
#+end_src

#+NAME: A note about what installs belong here and which don't
#+begin_comment
The above package list and script installs what I consider necessary for a
minimally functional copy of my setup. Pandoc and rofi for example aren't
necessary for i3 or emacs to work. But they are an important part of my flow.
My goal for this particular section is that that it should the minimal installs
necessary for _functional day-to-day_ work. It is my goal to be able to restart my
system from this section, finish the work week, and then I can address other
requirements as necessary.
#+end_comment

*** fzf
I use [[https://github.com/junegunn/fzf][fzf]] for shell history + completion. Completion of file names, configured
ssh servers, environment variables, and probably a lot of other things can be
triggered with ~**~.
#+begin_src shell :results output
git clone --depth 1 https://github.com/junegunn/fzf.git ~/.fzf
cd ~/.fzf/
./install
#+end_src

#+RESULTS:
#+begin_example
Downloading bin/fzf ...
  - Already exists
  - Checking fzf executable ... 0.17.5

Generate /home/sam/.fzf.bash ... OK
Generate /home/sam/.fzf.zsh ... OK

Update /home/sam/.bashrc:
  - [ -f ~/.fzf.bash ] && source ~/.fzf.bash
    - Already exists: line #1

Update /home/sam/.zshrc:
  - [ -f ~/.fzf.zsh ] && source ~/.fzf.zsh
    - Already exists: line #76

Finished. Restart your shell or reload config file.
   source ~/.bashrc  # bash
   source ~/.zshrc   # zsh

Use uninstall script to remove fzf.

For more information, see: https://github.com/junegunn/fzf
#+end_example

** X11 (and other things that start with X)
*** xinitrc
:PROPERTIES:
:ID:       c02ec5f1-ea87-40b2-a353-6e088285d8a9
:END:
A very minimal xinitrc to load up my ~.Xresources~ before executing i3. Also I use
a noweb variable to include any other lines before i3 is executed.
#+begin_src shell :tangle "~/.xinitrc" :noweb yes
[[ -f ~/.Xresources ]] && xrdb -merge "${HOME}/.Xresources"
<<xinitrc-pre-i3>>
exec i3
#+end_src
*** .Xresources (some but not all)
:PROPERTIES:
:ID:       b24a26b9-8f57-48c5-8fd4-588833966455
:END:
I used [[https://github.com/auduchinok/base16-builder][base16-builder]] to generate an ~.Xresources~ template for the spacemacs dark theme.
#+begin_src shell
! Base16 Spacemacs
! Scheme: Nasser Alshammari (https://github.com/nashamri/spacemacs-theme)

#define base00 #1f2022
#define base01 #282828
#define base02 #444155
#define base03 #585858
#define base04 #b8b8b8
#define base05 #a3a3a3
#define base06 #e8e8e8
#define base07 #f8f8f8
#define base08 #f2241f
#define base09 #ffa500
#define base0A #b1951d
#define base0B #67b11d
#define base0C #2d9574
#define base0D #4f97d7
#define base0E #a31db1
#define base0F #b03060

*foreground:   base05
*background:   base00
*cursorColor:  base05

*color0:       base00
*color1:       base08
*color2:       base0B
*color3:       base0A
*color4:       base0D
*color5:       base0E
*color6:       base0C
*color7:       base05

*color8:       base03
*color9:       base08
*color10:      base0B
*color11:      base0A
*color12:      base0D
*color13:      base0E
*color14:      base0C
*color15:      base07

! Note: colors beyond 15 might not be loaded (e.g., xterm, urxvt),
! use 'shell' template to set these if necessary
*color16:      base09
*color17:      base0F
*color18:      base01
*color19:      base02
*color20:      base04
*color21:      base06
#+end_src

Some other default ~.Xresources~ settings. Enable unicode, save very many lines,
and then set some Xft settings as well. Full disclosure, I don't actually know
what all the Xft settings are for.
#+begin_src shell :tangle "~/.Xresources"
*utf8:                  1
*saveLines:             999999
#+end_src

What is an ~Xft~ setting? I have no idea
#+begin_src shell :tangle "~/.Xresources"
!-- Xft settings -- !
Xft.dpi:        144
Xft.rgba:       rgb
Xft.autohint:   0
Xft.lcdfilter:  lcddefault
Xft.hintstyle:  hintslight
Xft.hinting:    1
Xft.antialias:  1
#+end_src

Cursor settins.
#+begin_src shell :tangle "~/.Xresources"
Xcursor.theme: xcursor-breeze
Xcursor.size:                     0
#+end_src
** Shell
*** zsh
**** Environment
:PROPERTIES:
:ID:       34b5f30b-cb5b-463d-89e8-e20aff13f736
:END:
 #+begin_src shell :tangle "~/.zshenv"
export PATH=/home/sam/bin:/usr/local/bin:/usr/local/sbin:/usr/bin:/bin:/usr/sbin:/sbin:$PATH
 #+end_src
**** Antigen
:PROPERTIES:
:ID:       bfb63105-5c3b-4a20-99cb-571aa9a48f38
:END:
I use antigen + oh-my-zsh to manage my zsh config for the most part
#+begin_src  shell :tangle "~/.zshrc"
source ~/.antigen.zsh
antigen use oh-my-zsh

antigen bundle colored-man-pages
antigen bundle colorize
antigen bundle virtualenvwrapper
antigen bundle pip
antigen bundle python

antigen theme https://github.com/VidalChavez/pygmalion.git --loc=pygmalion

antigen apply
#+end_src
**** Functions
:PROPERTIES:
:ID:       79e8b3d6-3631-4f98-8174-6d295e26c347
:END:
Here are all of my custom zsh functions. I also tend to use functions over
aliases.
#+begin_src shell :tangle "~/.zshrc"
function jql() { jq -C "." <$* | less; }
function cowfig() {figlet "$*" | cowsay -n}
function cpcowfig() {figlet "$*" | cowsay -n | pbcopy}
function agp() {ag --py $*}
function gitsync() {rsync -t $(git diff --name-only) --relative $1}
function luigiui() {open -a "Google Chrome" $(plumb --host dev-magnezone-$1-1.rubikloudcorp.com status $2 | jq -r '.owner_public_ip' | awk ' {print "http://" $0 ":8082"} ')}
function jn() {open -a "Google Chrome" "http://localhost:$1/tree?"}
function jigh() {jig --host dev-configapi.rubikloudcorp.com $*}
function plumbh() {plumb --host dev-magnezone.rubikloudcorp.com $*}
function plumbh-log() {plumbh log $1 stdout > log && vim log}

# Rubikloud Functions
function lithium-jupyter() {scp spillsworth@lithium:/home/spillsworth/.run/current_kernel.json . && jupyter console --existing ./current_kernel.json --ssh lithium}
function saws() {aws ec2 ${1}-instances --instance-ids i-01a4312b35d89399c  --region eu-west-1}
function s3fstoken() {
    aws-vault exec --no-session --assume-role-ttl 12h ${1:-default} -- python -c 'import os; print("""s3 = s3fs.S3FileSystem(key="{}", secret="{}", token="{}")""".format(os.getenv("AWS_ACCESS_KEY_ID"), os.getenv("AWS_SECRET_ACCESS_KEY"), os.getenv("AWS_SESSION_TOKEN")))'
}
function s3atoken() {
    aws-vault exec --no-session --assume-role-ttl 12h ${1:-default} -- python -c 'import os; print("""
hadoop_conf.set("fs.s3a.aws.credentials.provider", "org.apache.hadoop.fs.s3a.TemporaryAWSCredentialsProvider")
hadoop_conf.set("fs.s3a.access.key", "{}")
hadoop_conf.set("fs.s3a.secret.key", "{}")
hadoop_conf.set("fs.s3a.session.token", "{}")
""".format(os.getenv("AWS_ACCESS_KEY_ID"), os.getenv("AWS_SECRET_ACCESS_KEY"), os.getenv("AWS_SESSION_TOKEN")))'
}
#+end_src

An extraction function I took from the bashrc in manjaro:
#+begin_src shell :tangle "~/.zshrc"
function ex () {
  if [ -f $1 ] ; then
    case $1 in
      *.tar.bz2)   tar xjf $1   ;;
      *.tar.gz)    tar xzf $1   ;;
      *.bz2)       bunzip2 $1   ;;
      *.rar)       unrar x $1     ;;
      *.gz)        gunzip $1    ;;
      *.tar)       tar xf $1    ;;
      *.tbz2)      tar xjf $1   ;;
      *.tgz)       tar xzf $1   ;;
      *.zip)       unzip $1     ;;
      *.Z)         uncompress $1;;
      *.7z)        7z x $1      ;;
      *)           echo "'$1' cannot be extracted via ex()" ;;
    esac
  else
    echo "'$1' is not a valid file"
  fi
}
#+end_src
**** Exports and aliases
:PROPERTIES:
:ID:       424bc62d-1633-4633-8e9b-82f47767e150
:END:
Here I export some values and set a few aliases
#+begin_src shell :tangle "~/.zshrc"
export GTAGSLABEL=pygments
export EDITOR='emacsclient -a vim -u -q'

alias ec='emacsclient -u -q'
alias l='ls -lhFu'
alias tmux="tmux -2 -u"
alias zshconfig="ec ~/.zshrc"
alias pbcopy='xclip -selection clipboard'
alias pbpaste='xclip -selection clipboard -o'
#+end_src
**** Terminal specific settings
:PROPERTIES:
:ID:       1d545107-9939-4d9a-8dc9-46d465e5afee
:END:
#+begin_src shell :tangle "~/.zshrc"
bindkey -v
KEYTIMEOUT=1

setopt CORRECT

# History options
HISTSIZE=10000000
SAVEHIST=10000000
setopt inc_append_history
setopt share_history
setopt HIST_EXPIRE_DUPS_FIRST    # Expire duplicate entries first when trimming history.
setopt HIST_IGNORE_DUPS          # Don't record an entry that was just recorded again.
setopt HIST_IGNORE_ALL_DUPS      # Delete old recorded entry if new entry is a duplicate.
setopt HIST_SAVE_NO_DUPS         # Don't write duplicate entries in the history file.
setopt HIST_VERIFY               # Don't execute immediately upon history expansion.
#+end_src

I also have some terminal settings explicitly for when the terminal is dumb.
This is the case when using emacs + tramp to work remotely. When remoting into a
machine via tramp, all of the zsh config can really slow it down and also the
prompt can cause problems (it's been a long time since I set this up and I don't
remember the exact issue I was having).
#+begin_src shell :tangle "~/.zshrc"
if [[ "$TERM" == "dumb" ]]
then
    unsetopt zle
    unsetopt prompt_cr
    unsetopt prompt_subst
    unfunction precmd
    unfunction preexec
    PS1='$ '
fi
#+end_src

I use ~fzf~ for history search/completion.
#+begin_src shell :tangle "~/.zshrc"
[ -f ~/.fzf.zsh ] && source ~/.fzf.zsh
#+end_src

Finally, source the environment file
#+begin_src shell :tangle "~/.zshrc"
source ~/.zshenv
#+end_src
*** urxvt
:PROPERTIES:
:ID:       1aacc5fb-6982-414a-9551-74d960b4c2f6
:END:

Set the spacemacs colour scheme for URxvt.
#+begin_src shell :tangle "~/.Xresources"
! Base16 Spacemacs
! Scheme: Nasser Alshammari (https://github.com/nashamri/spacemacs-theme)

! URxvt*tintColor:                      color
! URxvt*fadeColor:                      color

URxvt*background:                     #1f2022
URxvt*foreground:                     #a3a3a3
URxvt*cursorColor:                    #a3a3a3

! URxvt*colorBD:                        color
! URxvt*colorIT:                        color
! URxvt*colorUL:                        color
! URxvt*colorRV:                        color
! URxvt*underlineColor:                 color
URxvt*scrollColor:                    #a3a3a3
! URxvt*troughColor:                    color
URxvt*highlightColor:                 #444155
URxvt*highlightTextColor:             #b8b8b8
! URxvt*cursorColor2:                   color
! URxvt*pointerColor:                   color
! URxvt*pointerColor2:                  color
! URxvt*borderColor:                    color
! URxvt*tab-bg:                         colour
! URxvt*tab-fg:                         colour
! URxvt*tabbar-bg:                      colour
! URxvt*tabbar-fg:                      colour

URxvt*color0:                         #1f2022
URxvt*color1:                         #f2241f
URxvt*color2:                         #67b11d
URxvt*color3:                         #b1951d
URxvt*color4:                         #4f97d7
URxvt*color5:                         #a31db1
URxvt*color6:                         #2d9574
URxvt*color7:                         #a3a3a3
URxvt*color8:                         #585858
URxvt*color9:                         #f2241f
URxvt*color10:                        #67b11d
URxvt*color11:                        #b1951d
URxvt*color12:                        #4f97d7
URxvt*color13:                        #a31db1
URxvt*color14:                        #2d9574
URxvt*color15:                        #f8f8f8

! 256 color space
URxvt*color16:                        #ffa500
URxvt*color17:                        #b03060
URxvt*color18:                        #282828
URxvt*color19:                        #444155
URxvt*color20:                        #b8b8b8
URxvt*color21:                        #e8e8e8

#+end_src

Some ~.Xresources~ configuration for urxvt, my terminal emulator of choice.

Set the default font to be Iosevka, with Symbola as a backup for any missing
glyphs. So far this has been a really great combination for me.
#+begin_src shell :tangle "~/.Xresources"
! -- URxvt Fonts -- !
URxvt.font:xft:Iosevka:pixelsize=16:style=regular
URxvt.boldFont:xft:Iosevka:pixelsize=16:style=bold
URxvt.italicFont:xft:Iosevka:pixelsize=16:style=italic
URxvt.bolditalicFont:xft:Iosevka:pixelsize=16:style=bold:style=italic
#+end_src

The ~URxvt*letterSpace~ setting helps with cases where some font glyphs are not
truly monospaced. This can be an issue when using something like font-awesome.
I'm not sure I need this since I'm using Symbola instead, but it's something to
keep in mind.
#+begin_src shell :tangle "~/.Xresources"
URxvt*letterSpace: 2
#+end_src

Finally just some straightforward terminal settings: allow bold fonts, turn off
the scrollbar, and switch the cursor to an underline.
#+begin_src shell :tangle "~/.Xresources"
URxvt*allow_bold: true
URxvt.scrollBar: false
URxvt*cursorUnderline: true
URxvt.depth: 32
#+end_src

Transparency
#+begin_src shell :tangle "~/.Xresources"
URxvt*inheritPixmap:            true
URxvt*transparent:              true
URxvt*shading:                  138
#+end_src

#+begin_src shell :tangle "~/.Xresources"
URxvt.perl-ext: default,url-select,matcher,clipboard,font-size
URxvt.keysym.M-u: perl:url-select:select_next
URxvt.url-select.launcher: /usr/bin/qutebrowser
URxvt.url-select.underline: true
URxvt.keysym.C-Up: perl:font-size:increase
URxvt.keysym.C-Down: perl:font-size:decrease
URxvt.keysym.C-S-Up: perl:font-size:incglobal
URxvt.keysym.C-S-Down: perl:font-size:decglobal
URxvt.keysym.C-c: perl:clipboard:copy
URxvt.keysym.C-v: perl:clipboard:paste
#+end_src

** i3
*** Configuration
:PROPERTIES:
:ID:       705e0a62-fe76-4269-bd44-5a7ee7d62f80
:END:
**** Set variables
:PROPERTIES:
:ID:       392bea2b-c4cb-4c01-9877-693ca6a50fe5
:END:

I'm setting some variables first to keep them in an easy-to-find place,
for easy updating. These are either things I think I might want to change
(~$mod~), or commands that will be executed that I might want to update frequently.

#+begin_src shell :tangle "~/.config/i3/config"
set $mod Mod4
set $term --no-startup-id urxvt
set $menu --no-startup-id rofi -combi-mode "window#drun#run" -show combi -modi combi -show-icons -display-combi ""
set $pass --no-startup-id ~/bin/rofi-pass -display-pass "sam"
set $barcmd i3status
set $lock --no-startup-id ~/bin/i3lock-extra -p 5 -m pixelize
#+end_src

**** Beautify
:PROPERTIES:
:ID:       e8ecd02b-b952-4f4f-8ff4-6e64891d3267
:END:
The beautifying part of my i3 configuration: font settings, borders, colours,
generally making things pretty.

I like to use the [[https://github.com/be5invis/iosevka][Iosevka]] font for everything.
#+begin_src shell :tangle "~/.config/i3/config"

# Font for window titles. Will also be used by the bar unless a different font
# is used in the bar {} block below.

font pango: Iosevka 8
#+end_src

Border settings
#+begin_src shell :tangle "~/.config/i3/config"
new_window pixel 1
new_float normal

hide_edge_borders none

bindsym $mod+u border none
bindsym $mod+y border pixel 1
bindsym $mod+n border normal
#+end_src

***** Autoname Workspaces
:PROPERTIES:
:ID:       76b3a932-ac4d-4d0a-91ea-6df9e6749960
:END:

There is a [[https://github.com/justbuchanan/i3scripts/blob/master/autoname_workspaces.py][cute script]] that will replace windowspace numbers with icons showing
the running programs in each space.
#+begin_src shell
git clone git@github.com:justbuchanan/i3scripts ~/.etc/i3scripts
chmod +x ~/.etc/i3scripts/autoname_workspaces.py
#+end_src

#+RESULTS:

Install the dependencies:
#+begin_src shell
pip install --user i3ipc fontawesome
#+end_src

#+RESULTS:
| Collecting   | i3ipc       |                                                                                                                                                     |                         |              |             |      |        |        |
| Using        | cached      | https://files.pythonhosted.org/packages/83/9a/c44f96403a34dddf4359bb56f9564df77c78a7b444fa83a6a5330a514290/i3ipc-1.6.0.tar.gz                       |                         |              |             |      |        |        |
| Collecting   | fontawesome |                                                                                                                                                     |                         |              |             |      |        |        |
| Using        | cached      | https://files.pythonhosted.org/packages/15/10/f34aa20857e04ac0e3c5712a4e0f54c92ae49807bc55736a808429251784/fontawesome-5.7.2.post1-py3-none-any.whl |                         |              |             |      |        |        |
| Collecting   | enum-compat | (from                                                                                                                                               | i3ipc)                  |              |             |      |        |        |
| Using        | cached      | https://files.pythonhosted.org/packages/95/6e/26bdcba28b66126f66cf3e4cd03bcd63f7ae330d29ee68b1f6b623550bfa/enum-compat-0.0.2.tar.gz                 |                         |              |             |      |        |        |
| Installing   | collected   | packages:                                                                                                                                           | enum-compat,            | i3ipc,       | fontawesome |      |        |        |
| Running      | setup.py    | install                                                                                                                                             | for                     | enum-compat: | started     |      |        |        |
| Running      | setup.py    | install                                                                                                                                             | for                     | enum-compat: | finished    | with | status | 'done' |
| Running      | setup.py    | install                                                                                                                                             | for                     | i3ipc:       | started     |      |        |        |
| Running      | setup.py    | install                                                                                                                                             | for                     | i3ipc:       | finished    | with | status | 'done' |
| Successfully | installed   | enum-compat-0.0.2                                                                                                                                   | fontawesome-5.7.2.post1 | i3ipc-1.6.0  |             |      |        |        |

And add to the i3 config
#+begin_src shell :tangle "~/.config/i3/config"
exec_always --no-startup-id ~/.etc/i3scripts/autoname_workspaces.py &
#+end_src
**** Functionality
This section contains little snippets to provide a certain functionality or
behaviour in i3.
***** Auto focus to urgent window
:PROPERTIES:
:ID:       5541cb47-3f37-4a7e-9166-f3ac16276943
:END:
If a workspace has an urgent window, then I want to switch to that workspace
automatically. I use the running emacsclient (in GUI mode) as my editor and if
the terminal triggers an edit (through git or pass for example) then this
sitting causes the focus to automatically switch to emacs. Very nice.

#+begin_src shell :tangle "~/.config/i3/config"
for_window [urgent=latest] focus
#+end_src
***** Function of caps lock key
:PROPERTIES:
:ID:       7a4e750d-d49a-4603-9749-f058cf16aeb9
:END:
Remap the caps lock key to another control key, and have act as the escape key
when tapped.
#+begin_src shell :tangle "~/.config/i3/config"
exec --no-startup-id setxkbmap -option ctrl:nocaps
exec --no-startup-id xcape -e 'Control_L=Escape'
#+end_src
**** Keybindings
:PROPERTIES:
:ID:       01df5ea3-4821-4c01-b828-2b21d532eaa2
:END:
To start, I'm just stealing the whole configuration setup by Jess Frazelle, and
can be [[https://github.com/jessfraz/dotfiles/blob/master/.i3/config][found here]]
#+begin_src shell :tangle "~/.config/i3/config"
# Use Mouse+$mod to drag floating windows to their wanted position
floating_modifier $mod

# start a terminal
bindsym $mod+Return exec $term

# start dmenu
bindsym $mod+d exec $menu

# pass menu
bindsym $mod+p exec $pass

# kill focused window
bindsym $mod+Shift+q kill

# change focus
bindsym $mod+Left focus left
bindsym $mod+Down focus down
bindsym $mod+Up focus up
bindsym $mod+Right focus right

# move to monitor
bindsym $mod+Ctrl+Left move workspace to output left
bindsym $mod+Ctrl+Right move workspace to output right

# alternatively, you can use the cursor keys:
# bindsym $mod+Left focus left
# bindsym $mod+Down focus down
# bindsym $mod+Up focus up
# bindsym $mod+Right focus right

# move focused window
bindsym $mod+Shift+Left move left
bindsym $mod+Shift+Down move down
bindsym $mod+Shift+Up move up
bindsym $mod+Shift+Right move right

# workspace back and forth (with/without active container)
workspace_auto_back_and_forth yes
bindsym $mod+b workspace back_and_forth
bindsym $mod+Shift+b move container to workspace back_and_forth; workspace back_and_forth

# split orientation
bindsym $mod+bar split h;exec notify-send 'tile horizontally'
bindsym $mod+minus split v;exec notify-send 'tile vertically'
bindsym $mod+q split toggle

# enter fullscreen mode for the focused container
bindsym $mod+f fullscreen toggle

# change container layout (stacked, tabbed, toggle split)
bindsym $mod+s layout stacking
bindsym $mod+w layout tabbed
bindsym $mod+e layout toggle split

# toggle tiling / floating
bindsym $mod+Shift+space floating toggle

# change focus between tiling / floating windows
bindsym $mod+space focus mode_toggle

# focus the parent container
bindsym $mod+a focus parent

# move the currently focused window to the scratchpad
bindsym $mod+Shift+BackSpace move scratchpad

# Show the next scratchpad window or hide the focused scratchpad window.
# If there are multiple scratchpad windows, this command cycles through them.
bindsym $mod+BackSpace scratchpad show

# switch to workspace
bindsym $mod+1 workspace number 1
bindsym $mod+2 workspace number 2
bindsym $mod+3 workspace number 3
bindsym $mod+4 workspace number 4
bindsym $mod+5 workspace number 5
bindsym $mod+6 workspace number 6
bindsym $mod+7 workspace number 7
bindsym $mod+8 workspace number 8
bindsym $mod+9 workspace number 9

# move focused container to workspace
bindsym $mod+Shift+1 move container to workspace number 1
bindsym $mod+Shift+2 move container to workspace number 2
bindsym $mod+Shift+3 move container to workspace number 3
bindsym $mod+Shift+4 move container to workspace number 4
bindsym $mod+Shift+5 move container to workspace number 5
bindsym $mod+Shift+6 move container to workspace number 6
bindsym $mod+Shift+7 move container to workspace number 7
bindsym $mod+Shift+8 move container to workspace number 8
bindsym $mod+Shift+9 move container to workspace number 9

# audio controls
bindsym XF86AudioRaiseVolume exec amixer set Master 5%+ #increase sound volume
bindsym XF86AudioLowerVolume exec amixer set Master 5%- #decrease sound volume
bindsym XF86AudioMute exec amixer set Master +1 toggle # mute sound
bindsym XF86AudioMicMute exec amixer set Capture toggle # mute mic

# screen brightness controls
bindsym XF86MonBrightnessUp exec light -A 5 # increase screen brightness
bindsym XF86MonBrightnessDown exec light -U 5 # decrease screen brightness

# Screenshots
# bindsym --release Print exec import "${HOME}/Pictures/Screenshots/$(date +'%Y-%m-%d-%H-%M-%S').png"
bindsym $mod+Print --release exec --no-startup-id flameshot gui -p "${HOME}/Pictures/Screenshots"

# reload the configuration file
bindsym $mod+Shift+c reload
# restart i3 inplace (preserves your layout/session, can be used to upgrade i3)
bindsym $mod+Shift+r restart
# exit i3 (logs you out of your X session)
bindsym $mod+Shift+e exec "i3-nagbar -t warning -m 'You pressed the exit shortcut. Do you really want to exit i3? This will end your X session.' -B 'Yes, exit i3' 'i3-msg exit'"

# resize window (you can also use the mouse for that)
mode "resize" {
        # These bindings trigger as soon as you enter the resize mode

        # Pressing left will shrink the window’s width.
        # Pressing right will grow the window’s width.
        # Pressing up will shrink the window’s height.
        # Pressing down will grow the window’s height.
        bindsym $left       resize shrink width 10 px or 10 ppt
        bindsym $down       resize grow height 10 px or 10 ppt
        bindsym $up         resize shrink height 10 px or 10 ppt
        bindsym $right      resize grow width 10 px or 10 ppt

        # same bindings, but for the arrow keys
        bindsym Left        resize shrink width 10 px or 10 ppt
        bindsym Down        resize grow height 10 px or 10 ppt
        bindsym Up          resize shrink height 10 px or 10 ppt
        bindsym Right       resize grow width 10 px or 10 ppt

        # back to normal: Enter or Escape or $mod+r
        bindsym Return mode "default"
        bindsym Escape mode "default"
        bindsym $mod+r mode "default"
}

bindsym $mod+r mode "resize"

# Set shut down, restart and locking features
bindsym $mod+0 mode "$mode_system"
set $mode_system (l)ock, (e)xit, switch_(u)ser, (s)uspend, (h)ibernate, (r)eboot, (Shift+s)hutdown
mode "$mode_system" {
    bindsym l exec --no-startup-id $lock, mode "default"
    bindsym s exec --no-startup-id i3exit suspend, mode "default"
    bindsym u exec --no-startup-id i3exit switch_user, mode "default"
    bindsym e exec --no-startup-id i3exit logout, mode "default"
    bindsym h exec --no-startup-id i3exit hibernate, mode "default"
    bindsym r exec --no-startup-id i3exit reboot, mode "default"
    bindsym Shift+s exec --no-startup-id i3exit shutdown, mode "default"

    # exit system mode: "Enter" or "Escape"
    bindsym Return mode "default"
    bindsym Escape mode "default"
}

# Autostart applications
exec --no-startup-id /usr/lib/polkit-gnome/polkit-gnome-authentication-agent-1
exec --no-startup-id nitrogen --restore; sleep 1; compton -b
# exec --no-startup-id manjaro-hello
exec --no-startup-id nm-applet
exec --no-startup-id xfce4-power-manager
exec --no-startup-id pamac-tray
exec --no-startup-id clipit
# exec --no-startup-id blueman-applet
# exec_always --no-startup-id sbxkb
exec --no-startup-id start_conky_maia
# exec --no-startup-id start_conky_green
exec --no-startup-id xautolock -time 10 -locker $lock
exec_always --no-startup-id fix_xcursor

set_from_resource $term_background background
set_from_resource $term_foreground foreground
set_from_resource $term_color0     color0
set_from_resource $term_color1     color1
set_from_resource $term_color2     color2
set_from_resource $term_color3     color3
set_from_resource $term_color4     color4
set_from_resource $term_color5     color5
set_from_resource $term_color6     color6
set_from_resource $term_color7     color7
set_from_resource $term_color8     color8
set_from_resource $term_color9     color9
set_from_resource $term_color10    color10
set_from_resource $term_color11    color11
set_from_resource $term_color12    color12
set_from_resource $term_color13    color13
set_from_resource $term_color14    color14
set_from_resource $term_color15    color15

# Start i3bar to display a workspace bar (plus the system information i3status if available)
bar {
  i3bar_command i3bar
  status_command i3status --config "~/.config/i3/status.conf"
  position bottom

## please set your primary output first. Example: 'xrandr --output eDP1 --primary'
#	tray_output primary
#	tray_output eDP1

  bindsym button4 nop
  bindsym button5 nop
  font xft:Iosevka 10
  strip_workspace_numbers yes

    colors {
        background #222D31
        statusline #F9FAF9
        separator  #454947

#                      border  backgr. text
        focused_workspace  #F9FAF9 #16a085 #292F34
        active_workspace   #595B5B #353836 #FDF6E3
        inactive_workspace #595B5B #222D31 #EEE8D5
        binding_mode       #16a085 #2C2C2C #F9FAF9
        urgent_workspace   #16a085 #FDF6E3 #E5201D
    }
}

# hide/unhide i3status bar
bindsym $mod+m bar mode toggle

# Theme colors
# class                   border  backgr. text    indic.   child_border
  client.focused          #556064 #556064 #80FFF9 #FDF6E3
  client.focused_inactive #2F3D44 #2F3D44 #1ABC9C #454948
  client.unfocused        #2F3D44 #2F3D44 #1ABC9C #454948
  client.urgent           #CB4B16 #FDF6E3 #1ABC9C #268BD2
  client.placeholder      #000000 #0c0c0c #ffffff #000000

  client.background       #2B2C2B

#############################
### settings for i3-gaps: ###
#############################

# Set inner/outer gaps
gaps inner 14
gaps outer -2

# Additionally, you can issue commands with the following syntax. This is useful to bind keys to changing the gap size.
# gaps inner|outer current|all set|plus|minus <px>
# gaps inner all set 10
# gaps outer all plus 5

# Smart gaps (gaps used if only more than one container on the workspace)
smart_gaps on

# Smart borders (draw borders around container only if it is not the only container on this workspace)
# on|no_gaps (on=always activate and no_gaps=only activate if the gap size to the edge of the screen is 0)
smart_borders on

# Press $mod+Shift+g to enter the gap mode. Choose o or i for modifying outer/inner gaps. Press one of + / - (in-/decrement for current workspace) or 0 (remove gaps for current workspace). If you also press Shift with these keys, the change will be global for all workspaces.
set $mode_gaps Gaps: (o) outer, (i) inner
set $mode_gaps_outer Outer Gaps: +|-|0 (local), Shift + +|-|0 (global)
set $mode_gaps_inner Inner Gaps: +|-|0 (local), Shift + +|-|0 (global)
bindsym $mod+Shift+g mode "$mode_gaps"

mode "$mode_gaps" {
        bindsym o      mode "$mode_gaps_outer"
        bindsym i      mode "$mode_gaps_inner"
        bindsym Return mode "default"
        bindsym Escape mode "default"
}
mode "$mode_gaps_inner" {
        bindsym plus  gaps inner current plus 5
        bindsym minus gaps inner current minus 5
        bindsym 0     gaps inner current set 0

        bindsym Shift+plus  gaps inner all plus 5
        bindsym Shift+minus gaps inner all minus 5
        bindsym Shift+0     gaps inner all set 0

        bindsym Return mode "default"
        bindsym Escape mode "default"
}
mode "$mode_gaps_outer" {
        bindsym plus  gaps outer current plus 5
        bindsym minus gaps outer current minus 5
        bindsym 0     gaps outer current set 0

        bindsym Shift+plus  gaps outer all plus 5
        bindsym Shift+minus gaps outer all minus 5
        bindsym Shift+0     gaps outer all set 0

        bindsym Return mode "default"
        bindsym Escape mode "default"
}

#+end_src
*** i3status
:PROPERTIES:
:ID:       142e8f79-6f81-478b-934a-cec4551fd865
:END:
#+begin_src shell :tangle "~/.config/i3/status.conf"
# i3status configuration file.
# see "man i3status" for documentation.

# It is important that this file is edited as UTF-8.
# The following line should contain a sharp s:
# ß
# If the above line is not correctly displayed, fix your editor first!

general {
        colors = true
        interval = 5
        color_good = "#2AA198"
        color_bad = "#586E75"
        color_degraded = "#DC322F"
}

order += "cpu_usage"
# order += "load"
order += "disk /"
# order += "disk /home"
order += "wireless _first_"
#order += "ethernet _first_"
order += "volume master"
order += "battery all"
# order += "load"
order += "tztime local"
# order += "ipv6"

cpu_usage {
        format = " cpu  %usage "
}

load {
        format = " load %1min "
        # max_threshold = 0.3
}

disk "/" {
        # format = " hdd %avail "
        format = " ⛁ %avail "
}

ethernet _first_ {
# if you use %speed, i3status requires root privileges
        format_up = " lan: %ip %speed "
        format_down = " no lan "
}

battery all {
        # format = "%status %percentage %remaining %emptytime"
        format = " %status %percentage"
        format_down = "No battery"
        last_full_capacity = true
        integer_battery_capacity = true
        # status_chr = ""
        status_chr = "⚡"
        # status_bat = "bat"
        # status_bat = "☉"
        status_bat = ""
        # status_unk = "?"
        status_unk = ""
        # status_full = ""
        status_full = "☻"
        low_threshold = 15
        threshold_type = time
}

tztime local {
        # format = "%Y-%m-%d %H:%M:%S"
        format = " %d.%m. %H:%M "
}

volume master {
  format = "♪: %volume"
  format_muted = "♪: muted (%volume)"
  device = "default"
  mixer = "Master"
  mixer_idx = 0
}

#+end_src
*** i3lock
:PROPERTIES:
:ID:       e2bee763-884e-431f-b299-de1bf739163c
:END:

I like the lockscreen style described in [[https://github.com/brunodles/i3wm-conf][brunodles i3 config]], so I have stolen it.

#+begin_src shell :tangle "~/bin/i3lock-extra" :shebang "#!/usr/bin/env bash"
cfg_tmpdir="/run/user/$UID/i3lock-extra"
cfg_lockfile="$cfg_tmpdir/locked"
cfg_pixelize_scale='10'

err() { echo "$*" >&1; }

usage() {
  while read; do printf '%s\n' "$REPLY"; done <<- EOF
    Usage: i3lock-extra <-m mode> [args]
    Flags:
           --mode|-m <mode>    # Lock mode.
           --tmpdir|-d <path>  # Directory to store temporary files in. This should not be accessible by other users!
           --pixelize-scape|-p # For the pixelize mode only. Sets the number by which the image is resized down and
                                 back up to achieve the pixelize effect. For example, 4 means that it will be resized
                                 to 1/4 of the original and blown back up.
    Modes:
           rnd <dir>           # Use a random image from a dir.
           blur [img]          # Take a screenshot, blur it out. If provided, add an image on top.
           pixelize [img]      # Same as the above, but pixelize the image instead.
           img <img>           # Use the provided image.
EOF
}

random() {
  images_dir=$1

  images=( "$images_dir"/* )
  images_c="${#images[*]}"
  image_r=$(( RANDOM % images_c ))
  image="${images[$image_r]}"

  printf '%s' "$image"
}

deskshot() {
  declare scale_down scale_up
  declare dist_mode=$1; shift

  case "$dist_mode" in
    blur) scrot -e "convert -gaussian-blur 4x8 \$f ${cfg_tmpdir}/lockbg.png" "${cfg_tmpdir}/lockbg.png";;
    pixelize)
      scale_down=$(( 100/cfg_pixelize_scale ))
      scale_up=$(( ( 100/cfg_pixelize_scale ) * cfg_pixelize_scale * cfg_pixelize_scale ))

      scrot -e "convert \$f -scale "$scale_down"% -scale "$scale_up"% ${cfg_tmpdir}/lockbg.png" "${cfg_tmpdir}/lockbg.png"
    ;;
  esac

  if [[ "$1" ]]; then
    convert -gravity center -composite -matte "${cfg_tmpdir}/lockbg.png" "$1" "${cfg_tmpdir}/lockbg.png"
  fi

  image="${cfg_tmpdir}/lockbg.png"
  printf '%s' "$image"
}

lock() {
  >"$cfg_lockfile"
  i3lock -n -t -i "$image"
}

cleanup() {
  rm -f "$cfg_lockfile";
}

main() {
  umask 0077 # All files and dirs created should only be accessible by the user.

  while (( $# )); do
    case "$1" in
      --help|-h) usage; return 0;;
      --mode|-m) mode=$2; shift;;
      --tmpdir|-d) cfg_tmpdir=$2; shift;;
      --umask|-u) umask $2; shift;;
      --pixelize-scale|-p) cfg_pixelize_scale=$2; shift;;

      --) shift; break;;
      -*)
        err "Unknown key: $1"
        usage
        return 1
      ;;

      ,*) break;;
    esac
    shift
  done

  if ! [[ -d "$cfg_tmpdir" ]]; then
    mkdir -p "$cfg_tmpdir" || {
      return 1
    }
  fi

  case "${mode:-img}" in
    blur|pixelize) image=$( deskshot "$mode" "$1" );;

    rnd)
      (( $# )) || { usage; return 1; }
      image=$( random "$1" )
    ;;

    img)
      (( $# )) || { usage; return 1; }
      image="$1"
    ;;

    ,*) usage; return 1;;
  esac

  trap cleanup INT TERM EXIT

  until lock; do
    true
  done
}
main "$@"

#+end_src
*** fin
:PROPERTIES:
:ID:       0d5acb35-2fed-4d52-9dd6-a5621c1dd97f
:END:
This section contains any lines that must be executed at the end of the i3
config.

#+begin_src shell :tangle "~/.config/i3/config"
# run the merge for good colors
exec --no-startup-id xrdb -merge $HOME/.Xresources
#+end_src
** rofi
*** Installation

Now we can install i3, and some of the utilities that my i3 setup relies on.
These are rxvt, and scrot.
#+begin_src shell :dir "/sudo::" :cache no :results output
#+end_src

#+RESULTS:
#+begin_example
Reading package lists... 0%Reading package lists... 100%Reading package lists... Done
Building dependency tree... 0%Building dependency tree... 0%Building dependency tree... 50%Building dependency tree... 50%Building dependency tree       
Reading state information... 0%Reading state information... 0%Reading state information... Done
The following package was automatically installed and is no longer required:
  libllvm6.0
Use 'sudo apt autoremove' to remove it.
The following additional packages will be installed:
  libxcb-ewmh2
The following NEW packages will be installed:
  libxcb-ewmh2 rofi
0 upgraded, 2 newly installed, 0 to remove and 0 not upgraded.
Need to get 180 kB of archives.
After this operation, 632 kB of additional disk space will be used.
[33m0% [Working][0m            Get:1 http://archive.ubuntu.com/ubuntu bionic/main amd64 libxcb-ewmh2 amd64 0.4.1-1ubuntu1 [16.6 kB]
[33m1% [1 libxcb-ewmh2 2,615 B/16.6 kB 16%][0m[33m                                       17% [Working][0m             Get:2 http://archive.ubuntu.com/ubuntu bionic/universe amd64 rofi amd64 1.5.0-1 [163 kB]
[33m19% [2 rofi 2,613 B/163 kB 2%][0m[33m                              100% [Working][0m              Fetched 180 kB in 1s (266 kB/s)
Selecting previously unselected package libxcb-ewmh2:amd64.
(Reading database ... (Reading database ... 5%(Reading database ... 10%(Reading database ... 15%(Reading database ... 20%(Reading database ... 25%(Reading database ... 30%(Reading database ... 35%(Reading database ... 40%(Reading database ... 45%(Reading database ... 50%(Reading database ... 55%(Reading database ... 60%(Reading database ... 65%(Reading database ... 70%(Reading database ... 75%(Reading database ... 80%(Reading database ... 85%(Reading database ... 90%(Reading database ... 95%(Reading database ... 100%(Reading database ... 255922 files and directories currently installed.)
Preparing to unpack .../libxcb-ewmh2_0.4.1-1ubuntu1_amd64.deb ...
Unpacking libxcb-ewmh2:amd64 (0.4.1-1ubuntu1) ...
Selecting previously unselected package rofi.
Preparing to unpack .../rofi_1.5.0-1_amd64.deb ...
Unpacking rofi (1.5.0-1) ...
Setting up libxcb-ewmh2:amd64 (0.4.1-1ubuntu1) ...
Processing triggers for man-db (2.8.3-2ubuntu0.1) ...
Setting up rofi (1.5.0-1) ...
Processing triggers for libc-bin (2.27-3ubuntu1) ...
#+end_example
:ID: 6e941630-220d-404d-91af-0cfd516dfdb1
*** Configuration
:PROPERTIES:
:ID:       64a8ed9b-9c8b-48b6-9ac9-0dbbc9f72d5b
:END:

Visual settings for Rofi. Sets up the colour theme (solarized for now, need to
figure out something spacemacs-dark complimentary later), and also sets the font
and separator styles.
#+begin_src shell :tangle "~/.Xresources"
! -- ROFI Color theme -- !
rofi.color-enabled: true
rofi.color-window: #002b37, #002b37, #003642
rofi.color-normal: #002b37, #819396, #002b37, #003642, #819396
rofi.color-active: #002b37, #008ed4, #002b37, #003642, #008ed4
rofi.color-urgent: #002b37, #da4281, #002b37, #003642, #da4281

rofi.separator-style:                solid
rofi.font: Iosevka Nerd Font Complete Mono 10
rofi.combi_hide_mode_prefix: TRUE
#+end_src

#+begin_src shell :tangle "~/.Xresources"
rofi.case-sensitive: false
#+end_src

**** Rofi-Pass
:PROPERTIES:
:ID:       b0316724-c866-447e-9ec5-f9c74e4b9bde
:END:

My configuration for ~rofi-pass~ is written to =/home/sam/.config/rofi-pass/config=
#+begin_src shell :tangle "~/.config/rofi-pass/config"
URL_field='url'
USERNAME_field='user'
AUTOTYPE_field='autotype'
EDITOR='ec'
auto_enter='true'
default_user='srpillsworth@gmail.com'
#+end_src

These are the default keybindings for rofi-pass. I haven't changed anything, I'm
just including them here for easy reference
#+begin_src shell :tangle "~/.config/rofi-pass/config"
autotype="Alt+1"
type_user="Alt+2"
type_pass="Alt+3"
open_url="Alt+4"
copy_name="Alt+u"
copy_url="Alt+l"
copy_pass="Alt+p"
show="Alt+o"
copy_entry="Alt+2"
type_entry="Alt+1"
copy_menu="Alt+c"
action_menu="Alt+a"
type_menu="Alt+t"
help="Alt+h"
switch="Alt+x"
insert_pass="Alt+n"
#+end_src

** applications
*** org-protocol
:PROPERTIES:
:ID:       c8cd3185-fb80-421c-a89e-72f63080d040
:END:

Some setup is needed to get [[https://orgmode.org/worg/org-contrib/org-protocol.html#org4166fc4][org-protocol]] working nicely in linux. Org-protocol
can intercept calls from emacsclient to trigger custom actions. We need to tell
linux that org-protocol is an available protocol handler.

#+begin_src shell :tangle "~/.local/share/applications/org-protocol.desktop"
[Desktop Entry]
Name=org-protocol
Exec=/usr/bin/emacsclient -n %u
Type=Application
Terminal=false
Categories=System;
MimeType=x-scheme-handler/org-protocol;
#+end_src

Update the desktop database:
#+begin_src shell :dir "/sudo::" :results output
sudo update-desktop-database /home/sam/.local/share/applications
#+end_src

#+RESULTS:

~Org-protocol-capture-html~ captures webpages to a nice org heading by converting
to pandoc first.

Download the org-protocol capture script.
#+begin_src shell :results output
wget --output-document="/home/sam/.local/bin/org-protocol-capture-html.sh" https://raw.githubusercontent.com/alphapapa/org-protocol-capture-html/master/org-protocol-capture-html.sh
chmod +x /home/sam/.local/bin/org-protocol-capture-html.sh
#+end_src

#+RESULTS:

Finally we need a way to trigger capture from qutebrowser. I am using a [[https://www.reddit.com/r/emacs/comments/9ze1ln/capture_orgmode_bookmarks_from_qutebrowser_with/ea98mm2][script I
found on reddit]].
#+begin_src shell :tangle "~/.config/qutebrowser/userscripts/org-capture" :shebang "#!/usr/bin/env bash"
readonly CAPTURE_SCRIPT=~/.local/bin/org-protocol-capture-html.sh

# if we start with hints, delete title and selected text and use capture
if [[ "$QUTE_MODE" = "hints" ]]; then
    QUTE_TITLE=""
    QUTE_SELECTED_TEXT=""
fi

# we try to pass as many information as we have
if [[ -n "$QUTE_SELECTED_TEXT" ]]; then
    $CAPTURE_SCRIPT --heading "${QUTE_TITLE}" --url "${QUTE_URL}" "${QUTE_SELECTED_TEXT}"

elif [[ -n "$QUTE_TITLE" ]]; then
    $CAPTURE_SCRIPT --heading "${QUTE_TITLE}" --readability --url "${QUTE_URL}"

elif [[ -n "$QUTE_URL" ]]; then
    $CAPTURE_SCRIPT --readability --url "${QUTE_URL}"

fi
#+end_src
*** qutebrowser
**** config
:PROPERTIES:
:header-args:python: :tangle "~/.config/qutebrowser/config.py"
:ID:       207ae7ed-bfe5-49c5-84ec-2675ca8f71c5
:END:

Mostly default configurations here. I changed the editor command, and the tab
bar and when it shows. Other than that, fonts and keybindings are in sub-headings.
#+begin_src python
# Autogenerated config.py
# Documentation:
#   qute://help/configuring.html
#   qute://help/settings.html

# Uncomment this to still load settings configured via autoconfig.yml
# config.load_autoconfig()

# Always restore open sites when qutebrowser is reopened.
# Type: Bool
c.auto_save.session = True

# Enable JavaScript.
# Type: Bool
c.content.javascript.enabled = True

# Editor (and arguments) to use for the `open-editor` command. The
# following placeholders are defined: * `{file}`: Filename of the file
# to be edited. * `{line}`: Line in which the caret is found in the
# text. * `{column}`: Column in which the caret is found in the text. *
# `{line0}`: Same as `{line}`, but starting from index 0. * `{column0}`:
# Same as `{column}`, but starting from index 0.
# Type: ShellCommand
c.editor.command = ['ec', '{file}', '-c', 'normal {line}G{column0}l']

# Position of the tab bar.
# Type: Position
# Valid values:
#   - top
#   - bottom
#   - left
#   - right
c.tabs.position = 'left'

# When to show the tab bar.
# Type: String
# Valid values:
#   - always: Always show the tab bar.
#   - never: Always hide the tab bar.
#   - multiple: Hide the tab bar if only one tab is open.
#   - switching: Show the tab bar when switching tabs.
c.tabs.show = 'switching'

# Width (in pixels or as percentage of the window) of the tab bar if
# it's vertical.
# Type: PercOrInt
c.tabs.width = '15%'

#+end_src
***** fonts
:PROPERTIES:
:ID:       65bdee48-7d43-4c5c-8c61-3b4394f93c5d
:END:
#+begin_src python
c.fonts.monospace = "Iosevka Nerd Font Complete Mono, FontAwesome"
c.fonts.completion.entry = "7pt Iosevka Nerd Font Complete Mono, FontAwesome"
c.fonts.completion.category = "bold 10pt Iosevka Nerd Font Complete Mono, FontAwesome"
c.fonts.debug_console = "7pt Iosevka Nerd Font Complete Mono, FontAwesome"
c.fonts.downloads = "7pt Iosevka Nerd Font Complete Mono, FontAwesome"
c.fonts.hints = "bold 11px Iosevka Nerd Font Complete Mono, FontAwesome"
c.fonts.keyhint = "7pt Iosevka Nerd Font Complete Mono, FontAwesome"
c.fonts.messages.error = "7pt Iosevka Nerd Font Complete Mono, FontAwesome"
c.fonts.messages.info = "7pt Iosevka Nerd Font Complete Mono, FontAwesome"
c.fonts.messages.warning = "7pt Iosevka Nerd Font Complete Mono, FontAwesome"
c.fonts.prompts = "7pt Iosevka Nerd Font Complete Mono, FontAwesome"
c.fonts.statusbar = "7pt Iosevka Nerd Font Complete Mono, FontAwesome"
c.fonts.tabs = "7pt Iosevka Nerd Font Complete Mono, FontAwesome"
c.fonts.web.family.fixed = "Iosevka Nerd Font Complete Mono, FontAwesome"
c.fonts.web.family.sans_serif = "Iosevka Nerd Font Complete Mono, FontAwesome"
c.fonts.web.family.serif = "Iosevka Nerd Font Complete Mono, FontAwesome"
#+end_src

***** keybindings
:PROPERTIES:
:ID:       a86c2456-6291-47ea-aa16-9a65b053a652
:END:
#+begin_src python
# Bindings for normal mode
config.bind('zp', 'open -t https://getpocket.com/edit?url={url}')
config.bind("zw", "spawn --userscript ~/.config/qutebrowser/userscripts/org-capture")


# Bindings for insert mode
config.bind('<ctrl+k>', 'spawn --userscript ~/.config/qutebrowser/userscripts/password_fill', mode='insert')
#+end_src

**** userscripts
:PROPERTIES:
:header-args:shell: :shebang "#!/usr/bin/env bash"
:END:
***** Password Fill
:PROPERTIES:
:ID:       0663d977-fadd-4740-9d73-369976e71a7c
:END:
I'm not sure if this is still necessary? Now that I've switching to a linux
setup, I have a global keybinding to bring up the password menu, and it will
also auto-type. Still, I'll keep this around just in case.

#+begin_src shell :tangle "~/.config/qutebrowser/userscripts/password_fill" :shebang "#!/usr/bin/env bash"
help() {
    blink=$'\e[1;31m' reset=$'\e[0m'
cat <<EOF
This script can only be used as a userscript for qutebrowser
2015, Thorsten Wißmann <edu _at_ thorsten-wissmann _dot_ de>
In case of questions or suggestions, do not hesitate to send me an E-Mail or to
directly ask me via IRC (nickname thorsten\`) in #qutebrowser on freenode.

  $blink!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!$reset
  WARNING: the passwords are stored in qutebrowser's
           debug log reachable via the url qute://log
  $blink!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!$reset

Usage: run as a userscript form qutebrowser, e.g.:
  spawn --userscript ~/.config/qutebrowser/password_fill

Pass backend: (see also passwordstore.org)
  This script expects pass to store the credentials of each page in an extra
  file, where the filename (or filepath) contains the domain of the respective
  page. The first line of the file must contain the password, the login name
  must be contained in a later line beginning with "user:", "login:", or
  "username:" (configurable by the user_pattern variable).

Behavior:
  It will try to find a username/password entry in the configured backend
  (currently only pass) for the current website and will load that pair of
  username and password to any form on the current page that has some password
  entry field. If multiple entries are found, a zenity menu is offered.

  If no entry is found, then it crops subdomains from the url if at least one
  entry is found in the backend. (In that case, it always shows a menu)

Configuration:
  This script loads the bash script ~/.config/qutebrowser/password_fill_rc (if
  it exists), so you can change any configuration variable and overwrite any
  function you like.

EOF
}

set -o errexit
set -o pipefail
shopt -s nocasematch # make regexp matching in bash case insensitive

if [ -z "$QUTE_FIFO" ] ; then
    help
    exit
fi

error() {
    local msg="$*"
    echo "message-error '${msg//\'/\\\'}'" >> "$QUTE_FIFO"
}
msg() {
    local msg="$*"
    echo "message-info '${msg//\'/\\\'}'" >> "$QUTE_FIFO"
}
die() {
    error "$*"
    exit 0
}

javascript_escape() {
    # print the first argument in an escaped way, such that it can safely
    # be used within javascripts double quotes
    sed "s,[\\\\'\"],\\\\&,g" <<< "$1"
}

# ======================================================= #
# CONFIGURATION
# ======================================================= #
# The configuration file is per default located in
# ~/.config/qutebrowser/password_fill_rc and is a bash script that is loaded
# later in the present script. So basically you can replace all of the
# following definitions and make them fit your needs.

# The following simplifies a URL to the domain (e.g. "wiki.qutebrowser.org")
# which is later used to search the correct entries in the password backend. If
# you e.g. don't want the "www." to be removed or if you want to distinguish
# between different paths on the same domain.

simplify_url() {
    simple_url="${1##*://}" # remove protocol specification
    simple_url="${simple_url%%\?*}" # remove GET parameters
    simple_url="${simple_url%%/*}" # remove directory path
    simple_url="${simple_url%:*}" # remove port
    simple_url="${simple_url##www.}" # remove www. subdomain
}

# no_entries_found() is called if the first query_entries() call did not find
# any matching entries. Multiple implementations are possible:
# The easiest behavior is to quit:
#no_entries_found() {
#    if [ 0 -eq "${#files[@]}" ] ; then
#        die "No entry found for »$simple_url«"
#    fi
#}
# But you could also fill the files array with all entries from your pass db
# if the first db query did not find anything
# no_entries_found() {
#     if [ 0 -eq "${#files[@]}" ] ; then
#         query_entries ""
#         if [ 0 -eq "${#files[@]}" ] ; then
#             die "No entry found for »$simple_url«"
#         fi
#     fi
# }

# Another behavior is to drop another level of subdomains until search hits
# are found:
no_entries_found() {
    while [ 0 -eq "${#files[@]}" ] && [ -n "$simple_url" ]; do
        shorter_simple_url=$(sed 's,^[^.]*\.,,' <<< "$simple_url")
        if [ "$shorter_simple_url" = "$simple_url" ] ; then
            # if no dot, then even remove the top level domain
            simple_url=""
            query_entries "$simple_url"
            break
        fi
        simple_url="$shorter_simple_url"
        query_entries "$simple_url"
        #die "No entry found for »$simple_url«"
        # enforce menu if we do "fuzzy" matching
        menu_if_one_entry=1
    done
    if [ 0 -eq "${#files[@]}" ] ; then
        die "No entry found for »$simple_url«"
    fi
}

# Backend implementations tell, how the actual password store is accessed.
# Right now, there is only one fully functional password backend, namely for
# the program "pass".
# A password backend consists of three actions:
#  - init() initializes backend-specific things and does sanity checks.
#  - query_entries() is called with a simplified url and is expected to fill
#    the bash array $files with the names of matching password entries. There
#    are no requirements how these names should look like.
#  - open_entry() is called with some specific entry of the $files array and is
#    expected to write the username of that entry to the $username variable and
#    the corresponding password to $password

reset_backend() {
    init() { true ; }
    query_entries() { true ; }
    open_entry() { true ; }
}

# choose_entry() is expected to choose one entry from the array $files and
# write it to the variable $file.
choose_entry() {
    choose_entry_zenity
}

# The default implementation chooses a random entry from the array. So if there
# are multiple matching entries, multiple calls to this userscript will
# eventually pick the "correct" entry. I.e. if this userscript is bound to
# "zl", the user has to press "zl" until the correct username shows up in the
# login form.
choose_entry_random() {
    local nr=${#files[@]}
    file="${files[$((RANDOM % nr))]}"
    # Warn user, that there might be other matching password entries
    if [ "$nr" -gt 1 ] ; then
        msg "Picked $file out of $nr entries: ${files[*]}"
    fi
}

# another implementation would be to ask the user via some menu (like rofi or
# dmenu or zenity or even qutebrowser completion in future?) which entry to
# pick
MENU_COMMAND=( head -n 1 )
# whether to show the menu if there is only one entry in it
menu_if_one_entry=0
choose_entry_menu() {
    local nr=${#files[@]}
    if [ "$nr" -eq 1 ] && ! ((menu_if_one_entry)) ; then
        file="${files[0]}"
    else
        file=$( printf '%s\n' "${files[@]}" | "${MENU_COMMAND[@]}" )
    fi
}

choose_entry_rofi() {
    MENU_COMMAND=( rofi -p "qutebrowser> " -dmenu
                        -mesg $'Pick a password entry for <b>'"${QUTE_URL//&/&amp;}"'</b>' )
    choose_entry_menu || true
}

choose_entry_zenity() {
    MENU_COMMAND=( zenity --list --title "qutebrowser password fill"
                          --text "Pick the password entry:"
                          --column "Name" )
    choose_entry_menu || true
}

choose_entry_zenity_radio() {
    zenity_helper() {
        awk '{ print $0 ; print $0 }'                   \
        | zenity --list --radiolist                     \
                 --title "qutebrowser password fill"    \
                 --text "Pick the password entry:"      \
                 --column " " --column "Name"
    }
    MENU_COMMAND=( zenity_helper )
    choose_entry_menu || true
}

# =======================================================
# backend: PASS

# configuration options:
match_filename=1 # whether allowing entry match by filepath
match_line=0     # whether allowing entry match by URL-Pattern in file
                 # Note: match_line=1 gets very slow, even for small password stores!
match_line_pattern='^url: .*' # applied using grep -iE
user_pattern='^(user|username|login): '

GPG_OPTS=( "--quiet" "--yes" "--compress-algo=none" "--no-encrypt-to" )
GPG="gpg"
export GPG_TTY="${GPG_TTY:-$(tty 2>/dev/null)}"
command -v gpg2 &>/dev/null && GPG="gpg2"
[[ -n $GPG_AGENT_INFO || $GPG == "gpg2" ]] && GPG_OPTS+=( "--batch" "--use-agent" )

pass_backend() {
    init() {
        PREFIX="${PASSWORD_STORE_DIR:-$HOME/.password-store}"
        if ! [ -d "$PREFIX" ] ; then
            die "Can not open password store dir »$PREFIX«"
        fi
    }
    query_entries() {
        local url="$1"

        if ((match_line)) ; then
            # add entries with matching URL-tag
            while read -r -d "" passfile ; do
                if $GPG "${GPG_OPTS[@]}" -d "$passfile" \
                     | grep --max-count=1 -iE "${match_line_pattern}${url}" > /dev/null
                then
                    passfile="${passfile#$PREFIX}"
                    passfile="${passfile#/}"
                    files+=( "${passfile%.gpg}" )
                fi
            done < <(find -L "$PREFIX" -iname '*.gpg' -print0)
        fi
        if ((match_filename)) ; then
            # add entries with matching filepath
            while read -r passfile ; do
                passfile="${passfile#$PREFIX}"
                passfile="${passfile#/}"
                files+=( "${passfile%.gpg}" )
            done < <(find -L "$PREFIX" -iname '*.gpg' | grep "$url")
        fi
    }
    open_entry() {
        local path="$PREFIX/${1}.gpg"
        password=""
        local firstline=1
        while read -r line ; do
            if ((firstline)) ; then
                password="$line"
                firstline=0
            else
                if [[ $line =~ $user_pattern ]] ; then
                    # remove the matching prefix "user: " from the beginning of the line
                    username=${line#${BASH_REMATCH[0]}}
                    break
                fi
            fi
        done < <($GPG "${GPG_OPTS[@]}" -d "$path" | awk 1 )
    }
}
# =======================================================

# =======================================================
# backend: secret
secret_backend() {
    init() {
        return
    }
    query_entries() {
        local domain="$1"
        while read -r line ; do
            if [[ "$line" == "attribute.username = "* ]] ; then
                files+=("$domain ${line:21}")
            fi
        done < <( secret-tool search --unlock --all domain "$domain" 2>&1 )
    }
    open_entry() {
        local domain="${1%% *}"
        username="${1#* }"
        password=$(secret-tool lookup domain "$domain" username "$username")
    }
}
# =======================================================

# load some sane default backend
reset_backend
pass_backend
# load configuration
QUTE_CONFIG_DIR=${QUTE_CONFIG_DIR:-${XDG_CONFIG_HOME:-$HOME/.config}/qutebrowser/}
PWFILL_CONFIG=${PWFILL_CONFIG:-${QUTE_CONFIG_DIR}/password_fill_rc}
if [ -f "$PWFILL_CONFIG" ] ; then
    # shellcheck source=/dev/null
    source "$PWFILL_CONFIG"
fi
init

simplify_url "$QUTE_URL"
query_entries "${simple_url}"
no_entries_found
# remove duplicates
mapfile -t files < <(printf '%s\n' "${files[@]}" | sort | uniq )
choose_entry
if [ -z "$file" ] ; then
    # choose_entry didn't want any of these entries
    exit 0
fi
open_entry "$file"
#username="$(date)"
#password="XYZ"
#msg "$username, ${#password}"

[ -n "$username" ] || die "Username not set in entry $file"
[ -n "$password" ] || die "Password not set in entry $file"

js() {
cat <<EOF
    function isVisible(elem) {
        var style = elem.ownerDocument.defaultView.getComputedStyle(elem, null);

        if (style.getPropertyValue("visibility") !== "visible" ||
            style.getPropertyValue("display") === "none" ||
            style.getPropertyValue("opacity") === "0") {
            return false;
        }

        return elem.offsetWidth > 0 && elem.offsetHeight > 0;
    };
    function hasPasswordField(form) {
        var inputs = form.getElementsByTagName("input");
        for (var j = 0; j < inputs.length; j++) {
            var input = inputs[j];
            if (input.type == "password") {
                return true;
            }
        }
        return false;
    };
    function loadData2Form (form) {
        var inputs = form.getElementsByTagName("input");
        for (var j = 0; j < inputs.length; j++) {
            var input = inputs[j];
            if (isVisible(input) && (input.type == "text" || input.type == "email")) {
                input.focus();
                input.value = "$(javascript_escape "${username}")";
                input.blur();
            }
            if (input.type == "password") {
                input.focus();
                input.value = "$(javascript_escape "${password}")";
                input.blur();
            }
        }
    };

    var forms = document.getElementsByTagName("form");
    for (i = 0; i < forms.length; i++) {
        if (hasPasswordField(forms[i])) {
            loadData2Form(forms[i]);
        }
    }
EOF
}

printjs() {
    js | sed 's,//.*$,,' | tr '\n' ' '
}
echo "jseval -q $(printjs)" >> "$QUTE_FIFO"
#+end_src

* Plans
** DONE better lock screen
CLOSED: [2019-02-09 Sat 10:56]
- State "DONE"       from "TODO"       [2019-02-09 Sat 10:56]
** DONE still getting some unknown characters in terminal
CLOSED: [2019-02-16 Sat 14:33]
- State "DONE"       from "TODO"       [2019-02-16 Sat 14:33]
** DONE window management
CLOSED: [2019-02-09 Sat 10:56]
- State "DONE"       from "TODO"       [2019-02-09 Sat 10:56]
- try using i3
** TODO i3 gaps
** TODO polybar
** CANCELLED weechat + weeslack + weemacs
CLOSED: [2019-03-14 Thu 18:23]
- State "CANCELLED"  from "TODO"       [2019-03-14 Thu 18:23] \\
  emacs slack package works better, and probably will just use erc for irc channels/gitter
** TODO pystatus instead of i3status?
https://github.com/ultrabug/py3status
** TODO screenshots
** TODO save and restore i3 window layout
** TODO i3 alternating layours
https://github.com/olemartinorg/i3-alternating-layout
** TODO syncthing instead of dropbox?
https://docs.syncthing.net/intro/getting-started.html#getting-started
