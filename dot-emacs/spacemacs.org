#+begin_src emacs-lisp :exports none
  ;; DO NOT EDIT THIS FILE DIRECTLY
  ;; This is a file generated from a literate programing source file located at
  ;; https://github.com/samspills/dotfiles/blob/master/dot-emacs/spacemacs.org.
  ;; You should make any changes there and regenerate it from Emacs org-mode using C-c C-v t
#+end_src

* Spacemacs Setup
This is my attempt to convert my garbage monster mess of a =.spacemacs= file into
something that a human can read and understand.

Please note that this work is still very much in development. This file was very
much inspired by [[https://github.com/zzamboni/dot-emacs/blob/master/init.org#customized-variables][zzamboni's emacs config.org]].
** Meta Spacemacs Setup
This section contains configs for the config/startup process of spacemacs.
*** Setup use-package
#+BEGIN_SRC emacs-lisp
(setq configuration-layer-elpa-archives '(("melpa stable" . "stable.melpa.org/packages/")
                                          ("org" . "orgmode.org/elpa/")
                                          ("gnu" . "elpa.gnu.org/packages/")))
(setq package-archives '( ("melpa stable" . "stable.melpa.org/packages/")
                          ("org" . "orgmode.org/elpa/")
                          ("gnu" . "elpa.gnu.org/packages/")))
(package-refresh-contents)

(unless (package-installed-p 'use-package)
  (package-install 'use-package))

(eval-when-compile
  (require 'use-package))

(use-package general
  :ensure t
  :defer nil
  :config (general-evil-setup t))

#+END_SRC

By default all packages should be installed from package manager as that's the usual path. This is equivalent to setting =:ensure t= on each call to =use-package=. To disable set =:ensure nil= (this is done automatically for any packages using =:load-path= so shouldn't generally be needed).

#+BEGIN_SRC emacs-lisp
  (setq use-package-always-ensure t)
#+END_SRC

The =use-package-always-defer= sets =:defer true= as the default for all package declarations. This makes Emacs startup much faster by preventing packages from being loaded when Emacs starts, and only doing so when they are needed. Some packages don't work well with this, so you'll see some declarations when I explicitly set =:defer nil= to force the package to be loaded at startup, or =:defer n= to load the package, but only =n= seconds after startup.

  #+begin_src emacs-lisp
    (customize-set-variable 'use-package-always-defer t)
  #+end_src

This variable tells Emacs to prefer the =.el= file if it's newer, even if there is a corresponding =.elc= file. Also, use =auto-compile= to autocompile files as needed.

#+begin_src emacs-lisp
  (customize-set-variable 'load-prefer-newer t)
  (use-package auto-compile
    :defer nil
    :config (auto-compile-on-load-mode))
#+end_src
*** Increase garbage collector threshold

The default garbage collection threshold is 800kB, increasing this to 10MB for startup increases speed (from 11.0s -> 9.7s when I tested).

#+BEGIN_SRC emacs-lisp
  (setq gc-cons-threshold 10000000)

  ;; Restore after startup
  (add-hook 'after-init-hook
            (lambda ()
              (setq gc-cons-threshold 1000000)
              (message "gc-cons-threshold restored to %S"
                       gc-cons-threshold)))
#+END_SRC

*** Make it easy to edit this file

#+BEGIN_SRC emacs-lisp
  (defun find-config ()
    "Edit config.org"
    (interactive)
    (find-file "~/dotfiles/dot-emacs/spacemacs.org"))

  (spacemacs/set-leader-keys "f e c" 'find-config)
#+END_SRC
*** TODO Exec path from shell
Get shell commands to work in emacs by copying environment variables into emacs.

I'm still getting errors about setting my path in my =~/.zshrc= file even though
everything path related is in the =~/.zshenv= file. Need to look into this.
#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
  :config
  (exec-path-from-shell-initialize)
  (add-to-list 'exec-path "/usr/local/bin"))
#+END_SRC
*** Personal Prefix
Define personal prefix in the spacemacs menu for nesting commands under
#+BEGIN_SRC emacs-lisp
(spacemacs/declare-prefix "o" "sam")
#+END_SRC
*** Password Management
I use [[https://www.passwordstore.org/][pass]] to manage all my passwords, and this is now supported in emacs > 26 as a valid auth-source.
#+BEGIN_SRC emacs-lisp
(use-package auth-source)
(use-package auth-source-pass
  :after auth-source
  :defer nil
  :init
    (auth-source-pass-enable)
    (setq auth-source-debug t)
    (setq auth-sources '(password-store)))
#+END_SRC
** Spacemacs Personal Preferences
These are some straight-forward settings for my personal preferences. I didn't
know where else to put them, so they're all going here.
*** Keybindings
#+BEGIN_SRC emacs-lisp
(spacemacs/set-leader-keys "SPC" 'avy-goto-char-timer) ;; SPC-SPC then start typing a word
#+END_SRC
*** Helpers/Config type things
**** Customized Variables
Emacs has its own Customization mechanism for easily customizing many
parameters. To make it easier to manage, I keep the customized variables and
faces in a separate file and load it from the main file. A lot of my custom
settings are configured from this init file as well, but there are always some
which I change by hand for added flexibility.

#+BEGIN_SRC emacs-lisp
(setq custom-file "~/.emacs.d/custom.el")
(load custom-file)
#+END_SRC

**** Electric Indent Mode

Turn off electric indent mode, then keep it from being turned back on by any of my language layers
#+BEGIN_SRC emacs-lisp
(setq electric-indent-mode -1)
(add-hook 'after-change-major-mode-hook (lambda() (electric-indent-mode -1)))
#+END_SRC
**** Golden ratio
#+BEGIN_SRC emacs-lisp
(use-package golden-ratio
  :custom
  (golden-ratio-auto-scale t))
#+END_SRC
**** Misc.
Lock-files, indenting, my name, colours. Just things that I wasn't sure where else to put.
#+BEGIN_SRC emacs-lisp
  (setq create-lockfiles nil ; I don't care about locking files
        make-backup-files nil ; I don't like cleaning up backup-files
        user-full-name "Sam Pillsworth" ; my name
        ns-use-srgb-colorspace nil ; makes powerline separators look right
        ns-pop-up-frames nil
        split-height-threshold nil ; this line and next force preference for vertical splits
        split-width-threshold 0
        fill-column 100 ; fill in all buffers after 100 chars, overridden in specific lang settings
  )

  (spacemacs/toggle-indent-guide-globally-on)
#+END_SRC
*** Beautify things
Highlight parens etc. for improved readability.
#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC

*** Modeline
I use [[https://github.com/the-kenny/weechat.el][weechat]] inside of emacs, and I'd like to be able to see active buffers in the mode-line.
#+BEGIN_SRC emacs-lisp
(use-package tracking
  :preface
  (defvar tracking-mode-line-buffers)
  :config
  (spaceline-define-segment weetrack
    "weechat tracking"
    (when tracking-mode-line-buffers
      (powerline-raw tracking-mode-line-buffers))))
#+END_SRC

Configure spaceline to include tracking for weechat and toggle some built in toggles.
#+BEGIN_SRC emacs-lisp
(use-package spaceline
  :init
  :config
  (spaceline-spacemacs-theme 'weetrack)
  (spaceline-toggle-minor-modes-off)
  (spaceline-toggle-major-mode-off)
  (spaceline-toggle-purpose-off)
  (spaceline-toggle-buffer-size-off)
  (spaceline-toggle-org-pomodoro-on)
  (spacemacs/toggle-display-time-on))
#+END_SRC

*** Start the Emacs server
#+begin_src emacs-lisp
  (server-start)
#+end_src
** Org
I use =use-package= to load the =org= package, and put its configuration inside the
corresponding sections for keybindings (=:bind=), custom variables (=:custom=),
custom faces (=:custom-face=), hooks (=:hook=) and general configuration code
(=:config=), respectively. The contents of each section is populated with the
corresponding snippets that follow, using =org-babel= magic. You see here the
complete =use-package= declaration for completeness, but see the sections below
for the details on where each snippet comes from, and some other configuration
code that ends up outside this declaration.
#+begin_src emacs-lisp :noweb yes
(defvar sam/org-dir "~/Dropbox/life")
(use-package org
  :mode ("\\.org\\|org_archive\\'" . org-mode)
  :general
 <<org-mode-keybindings>>
  :custom
  <<org-mode-custom-vars>>
  :custom-face
  <<org-mode-faces>>
  :hook
  <<org-mode-hooks>>
  :config
  <<org-mode-config>>)
#+end_src

*** General Org Configuration
Keep the indentation well structured by setting =org-startup-indented= to =t=. This
is a must have. Makes it feel less like editing a big text file and more like a
purpose built editor for org-mode that forces the indentation. Thanks [[https://github.com/nickanderson/Level-up-your-notes-with-Org/blob/master/Level-up-your-notes-with-Org.org#automatic-visual-indention][Nick]] for
the tip!
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-mode-custom-vars
(org-startup-indented t)
#+END_SRC

Start files with headings folded. This is particularly good for massive
org-files.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-mode-custom-vars
(org-startup-folded t)
#+END_SRC

I keep all my org files in one directory, so I set some variables to make sure
that org-mode knows where it is.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-mode-custom-vars
(org-directory sam/org-dir)
(org-agenda-files (list sam/org-dir))
#+END_SRC

I use a GTD-style task setup, and I log things to an =inbogx.org= file from my
phone a lot. This means that I need to refile a lot of things frequently. These
settings make refiling a more pleasant experience. First, I allow completion of
the full output path, then I set =org-refile= to use the outline-path as a
completion target. Finally, I set the org-refile targets to be up to the 9th
heading level in all agenda files.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-mode-custom-vars
(org-outline-path-complete-in-steps nil)
(org-refile-use-outline-path t)
(org-refile-targets '((nil :maxlevel . 9)
                      (org-agenda-files :maxlevel . 9)))

#+END_SRC

I like to keep my properties and my logbook containing clock entries in
different drawers.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-mode-custom-vars
(org-drawers '("PROPERTIES" "LOGBOOK"))
#+END_SRC

*** Keybindings
I add my most used org functions under my personal keymap so that they're always available
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-mode-keybindings
(:prefix dotspacemacs-leader-key
 :states 'normal
         "oc" 'org-capture
         "os" 'org-attach-screenshot
         "od" 'org-agenda-daily-dashboard
         "ol" 'org-store-link
         "or" 'org-rubikloud
         "oj" 'org-journal
         "op" 'org-pomodoro
         "oi" 'org-clock-in
         "oo" 'org-clock-out)
#+END_SRC

Two of the keybindings, =or= and =oj= are helper bindings to quickly open my most
frequently referenced files. TODO can these functions/bindings be replaced with
bookmarks?
#+BEGIN_SRC emacs-lisp
(defun org-journal (&optional arg)
  (interactive "P")
  (find-file "~/Dropbox/life/journal.org"))
(defun org-rubikloud (&optional arg)
  (interactive "P")
  (find-file "~/Dropbox/life/rubikloud/rubikloud.org"))
#+END_SRC
*** Beautifying Org mode
I write a lot of documentation in org-mode, and it's a nicer experience if I
hide the formatting markers from myself.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-mode-custom-vars
(org-hide-emphasis-markers t)
#+END_SRC

I like my =TODO= keywords to match the spacemacs dark theme. (This doesn't seem to
be working right now though and needs to be investigated.)
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-mode-config
(setq org-todo-keyword-faces
      '(
        ("TODO" :foreground "#ce537a" :weight bold)
        ("DEADLINE" :foreground "#ce537a" :weight bold)
        ("NEXT" :foreground "#bc6ec5" :weight bold)
        ("STARTED" :foreground "#bc6ec5" :weight bold)
        ("DONE" :foreground "#2aa1ae" :weight bold)
        ("HOLD" :foreground "#4f97d7" :weight bold)
        ("WAITING" :foreground "#4f97d7" :weight bold)
        ("CANCELLED" :foreground "#2d9574" :weight bold)
        ("MEETING" :foreground "#5d4d7a" :weight bold)
        ))
#+END_SRC

Spacemacs automatically sets up =hl-todo= in all programming and text buffers.
According to [[https://github.com/tarsius/hl-todo/blob/master/hl-todo.el#L69-L71][this comment]] in the package, the mode shouldn't be getting
activated but it is anyway. So, I add a hook to turn it off in buffers with
org-mode.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-mode-hooks
(org-mode . (lambda () (hl-todo-mode -1)))
#+END_SRC

I like to keep my org-files very tightly wrapped. I think it makes them more
readable.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-mode-hooks
(org-mode . (lambda () (set-fill-column 80)))
(org-mode . turn-on-auto-fill)
#+END_SRC
**** Experimental
We choose a nice font for the document title and the section headings. The first
one found in the system from the list below is used, and the same font is used
for the different levels, in varying sizes.

#+begin_src emacs-lisp :tangle no
  (let* ((variable-tuple
          (cond ((x-list-fonts   "Source Sans Pro") '(:font   "Source Sans Pro"))
                ((x-list-fonts   "Lucida Grande")   '(:font   "Lucida Grande"))
                ((x-list-fonts   "Verdana")         '(:font   "Verdana"))
                ((x-family-fonts "Sans Serif")      '(:family "Sans Serif"))
                (nil (warn "Cannot find a Sans Serif Font.  Install Source Sans Pro."))))
         (base-font-color (face-foreground 'default nil 'default))
         (headline       `(:inherit default :weight bold :foreground ,base-font-color)))

    (custom-theme-set-faces
     'user
     `(org-level-8        ((t (,@headline ,@variable-tuple))))
     `(org-level-7        ((t (,@headline ,@variable-tuple))))
     `(org-level-6        ((t (,@headline ,@variable-tuple))))
     `(org-level-5        ((t (,@headline ,@variable-tuple))))
     `(org-level-4        ((t (,@headline ,@variable-tuple :height 1.1))))
     `(org-level-3        ((t (,@headline ,@variable-tuple :height 1.25))))
     `(org-level-2        ((t (,@headline ,@variable-tuple :height 1.5))))
     `(org-level-1        ((t (,@headline ,@variable-tuple :height 1.75))))
     `(org-document-title ((t (,@headline ,@variable-tuple :height 2.0 :underline nil))))))
#+end_src

I use proportional fonts in org-mode for the text, while keeping fixed-width fonts for blocks, so that source code, tables, etc. are shown correctly. These settings include:

Setting up the =variable-pitch= face to the proportional font I like to use. I'm currently alternating between my two favorites, [[https://en.wikipedia.org/wiki/Source_Sans_Pro][Source Sans Pro]] and [[https://en.wikipedia.org/wiki/Avenir_(typeface)][Avenir Next]].
  #+begin_src emacs-lisp :tangle no
    (variable-pitch ((t (:family "Source Sans Pro" :height 160 :weight light))))
    ;;(variable-pitch ((t (:family "Avenir Next" :height 160 :weight light))))
  #+end_src

  Setting up the =fixed-pitch= face to be the same as my usual =default= face. My current one is [[https://en.wikipedia.org/wiki/Inconsolata][Inconsolata]].
  #+begin_src emacs-lisp :tangle no
    (fixed-pitch ((t (:family "Inconsolata"))))
  #+end_src

  Setting up =visual-line-mode= and making all my paragraphs one single line, so
  that the lines wrap around nicely in the window according to their
  proportional-font size, instead of at a fixed character count, which does not
  work so nicely when characters have varying widths. I set up a hook that
  automatically enables =visual-line-mode= and =variable-pitch-mode= when entering
  org-mode.
  #+begin_src emacs-lisp :tangle no
    (org-mode . visual-line-mode)
    (org-mode . variable-pitch-mode)
  #+end_src
*** Getting things done with Org
:PROPERTIES:
:ID:       6485854B-0B45-43E4-928E-0B32EB686F04
:END:
**** Capturing
:PROPERTIES:
:ID:       85B593E5-998D-4455-972C-DFEF1AA3C30A
:END:
Setup some org capture templates. (TODO don't hardcode the file paths)
#+BEGIN_SRC emacs-lisp
(use-package org-capture
  :ensure nil
  :config
  (add-to-list 'org-capture-templates
                `("t" "Work Task" entry (file+headline "~/Dropbox/life/rubikloud/rubikloud.org" "Projects")
                  "* TODO %^{prompt} :inbox: \n%?"))
   (add-to-list 'org-capture-templates
                `("i" "Interruption" entry (file+olp+datetree "~/Dropbox/life/rubikloud/rubikloud.org")
                  "* %^{prompt}\n%U\n%?" :clock-in t :clock-resume t))
   (add-to-list 'org-capture-templates
                `("n" "Task Note" entry (file+olp+datetree "~/Dropbox/life/rubikloud/rubikloud.org")
                  "* %^{prompt} %^G \n%T\n%K\n%?"))
   (add-to-list 'org-capture-templates
                `("r" "Reference" entry (file+headline "~/Dropbox/life/rubikloud/rubikloud.org" "Reference")
                  "* %^{prompt}\n%U\n%?"))
   (add-to-list 'org-capture-templates
                `("j" "Journal" entry (file+olp+datetree "~/Dropbox/life/rubikloud/rubikloud.org")
                  "* %^{prompt}\n%U\n%?"))
   (add-to-list 'org-capture-templates
                `("T" "Personal Task" entry (file+olp+datetree "~/Dropbox/life/journal.org")
                  "* TODO %?"))
   (add-to-list 'org-capture-templates
                `("P" "Personal Event" entry (file "~/Dropbox/life/sam-cal.org")
                  "* %^{Description} \n %^T \n %^{Notes}"))
  (add-to-list 'org-capture-templates
                `("J" "Personal Journal" entry (file+olp+datetree "~/Dropbox/life/journal.org")
                  "* %^{prompt}\n%U\n%?"))
   (add-to-list 'org-capture-templates
                `("f" "Future Note" entry (file+olp+datetree "~/Dropbox/life/rubikloud/rubikloud.org")
                  "* %^{prompt} \n%t\n%?" :time-prompt :clock-in t :clock-resume t)))
#+END_SRC

Capturing external content can be made a lot easier using =org-mac-link= (included in contrib),
which implements the ability to grab links from different Mac apps and insert
them in the file. Bind =SPC o g= to call =org-mac-grab-link= to choose an application
and insert a link.
#+begin_src emacs-lisp
(use-package org-mac-link
  :ensure nil
  :after org
  :general
  (:prefix dotspacemacs-leader-key
   :states 'normal
           "og" 'org-mac-grab-link))
#+end_src

I often plot things in a jupyter-notebook. I could save them to a file and then
link to them in org-mode but I don't. Instead I take a screenshot and paste them
into my org files
#+BEGIN_SRC emacs-lisp
(use-package org-attach-screenshot
  :custom
  (org-attach-screenshot-command-line "screencapture -i %f")
  :config
  (setq org-attach-screenshot-dirfunction
        (lambda ()
          (progn (assert (buffer-file-name))
                 (concat (file-name-sans-extension (buffer-file-name))
                         "_Art_"))))
)
#+END_SRC

I also have a helper function to get a target headline when refiling during
captures. I'm not sure if this is used anymore though.
#+BEGIN_SRC emacs-lisp
(defun org-get-target-headline (&optional prompt)
  "Prompt for a location in an org file and jump to it.

This is for promping for refile targets when doing captures."
  (let* ((target (save-excursion
                   (org-refile-get-location prompt nil nil)))
         (file (nth 1 target))
         (pos (nth 3 target))
         )
    (with-current-buffer (find-file-noselect file)
      (goto-char pos)
      (goto-char (org-end-of-subtree)))))
#+END_SRC
**** Tasks and Agenda
Define more than the usual sequence of org-mode =TODO= states. Honestly, I think I
only use the first sequence, and this could probably be simplified.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-mode-config
(setq org-todo-keywords
      (quote ((sequence "TODO(t)" "NEXT(n)" "STARTED(s)" "DEADLINE(D)" "|" "DONE(d!)")
              (sequence "HOLD(h!)" "WAITING(w@/!)" "|" "CANCELLED(c@/!)" "MEETING(m)"))))
#+END_SRC

Set up my =org-agenda=. First, customize a bunch of variables to control what will
show up in the agenda and how it will look. In the =config= define an
=org-agenda-customer-command= to define my daily agenda view.
#+BEGIN_SRC emacs-lisp
(use-package org-agenda
  :ensure nil
  :custom
  (org-agenda-prefix-format " %T %t %s")
  (org-agenda-skip-scheduled-if-done t)
  (org-agenda-skip-deadline-if-done t)
  (org-agenda-skip-deadline-prewarning-if-scheduled 'pre-scheduled)
  (org-agenda-log-mode-items '(closed state)) ; don't show state changes
  (org-agenda-start-with-log-mode t)
  (org-enforce-todo-dependencies t)
  (org-enforce-todo-checkbox-dependencies nil)
  (org-agenda-tags-column -100)
  :config
  (setq org-agenda-custom-commands
        (quote (("d" "Daily Dashboard"
                 ((agenda "" ((org-agenda-span 1)
                              (org-agenda-log-mode 1)
                              (org-agenda-include-inactive-timestamps 't)
                              (org-agenda-overriding-header "Today")))
                  (todo "STARTED"
                        ((org-agenda-overriding-header "Started Tasks")))
                  (todo "NEXT"
                        ((org-agenda-overriding-header "Next Tasks")))
                  (tags-todo "github"
                        ((org-agenda-overriding-header "Github Tasks")))
                  (agenda "" ((org-agenda-start-on-weekday nil)
                              (org-agenda-start-day "+1d")
                              (org-agenda-span 7)
                              (org-agenda-overriding-header "Next 7 Days")))
                  (tags "inbox"
                        ((org-agenda-overriding-header "Inbox")))
                  )
                 ((org-agenda-tag-filter-preset '("-habit")))
                 ))))
)
#+END_SRC

I also define a helper function to open my daily agenda view in fewer keystrokes.
#+BEGIN_SRC emacs-lisp
(defun org-agenda-daily-dashboard (&optional arg)
    (interactive "P")
    (org-agenda arg "d"))
#+END_SRC

I want my work events to be pulled in from google calendar and shown in my org-agenda so I don't forget to go to my meetings.
#+BEGIN_SRC emacs-lisp
(use-package org-gcal
  :custom
  (org-gcal-client-id (auth-source-pass-get "client" "org/org-gcal.el"))
  (org-gcal-client-secret (auth-source-pass-get 'secret "org/org-gcal.el"))
  :config
  (setq org-gcal-file-alist '(("samantha.pillsworth@rubikloud.com" .  "/Users/sam/Dropbox/life/rubikloud/rubikloud_cal.org"))
        ))
#+END_SRC
**** Clocking
I have been trying to clock into my tasks so I can generate reports of
time-spend per client at the end of each week. These clocking functions are what
I have found to be most helpful so far.
#+BEGIN_SRC emacs-lisp
(use-package org-clocking
  :ensure nil
  :custom
  (org-clock-into-drawer t)
  (org-clock-out-remove-zero-time-clocks t)
  :hook
  (org-clock-in-hook . sam/clock-in-started)
  :config
  (defun sam/clock-in-started ()
    (when (not (and (boundp 'org-capture-mode) org-capture-mode))
      (cond
       ((and (member (org-get-todo-state) (list "TODO" "NEXT")))
        (org-todo "STARTED"))))
    )

)
#+END_SRC

I also have been experimenting with a package called =clocker=. It keeps the
org-mode file that is currently clocked in always visible if the functionality
is set, and also pops up an annoying message reminding me to clock-in everytime
I save a file and I'm not already clocked in. I turn off the visibility setting,
because I keep my agenda up on a second monitor at work anyway.
#+BEGIN_SRC emacs-lisp
(use-package clocker
    :ensure t
    :config
    (setq clocker-mode 1
          clocker-keep-org-file-always-visible nil
          )
    )
#+END_SRC
**** Ids
I like to use links between org headings. The default way that org will handle
heading links is just the outline map to the heading of interest. These links
break after I archive the original heading however, which I don't want. Instead
setup =org-id= and use a custom ID value for the links. This link style continues
to work even after the heading is archived or refiled.
#+BEGIN_SRC emacs-lisp
(use-package org-id
  :ensure nil
  :custom
  (org-id-link-to-org-use-id t)
)
#+END_SRC
*** Org-babel

To start, some custom variables to control the behaviour inside of org-babel
  source blocks. Mostly requiring that indenting be nice, stay nice, and that
  source blocks are fontified per their language mode.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-mode-custom-vars
(org-edit-src-content-indentation 0)
(org-src-preserve-indentation t)
(org-src-fontify-natively t)
(org-src-tab-acts-natively t)
#+END_SRC

I use python for 95% of my development work, and often use jupyter notebook/lab
for prototyping or research work. I've been experimenting with switching away
from jupyter to source code blocks using a shared ipython session. There was
some problem with this that I don't remember, which led to the following
settings.
#+BEGIN_SRC emacs-lisp
  (use-package ob-ipython
      ;; XXX org-capture: Capture abort: (json-readtable-error 47)
      ;; 作者假设 jupyter 正常运行，不好
      :disabled
      :homepage https://github.com/gregsexton/ob-ipython
      :ensure t
      ;; :config
      ;; (add-hook 'org-babel-after-execute-hook 'org-display-inline-images 'append)
      :defer t)
#+END_SRC

I use [[http://plantuml.com/][PlantUML]] graph language pretty often now, so we install first the general
=plantuml-mode= and the associated =org-babel= mode. We determine the location of
the PlantUML jar file automatically from the installed Homebrew formula, and use
it to configure both =ob-plantuml= and =plantuml-mode=.

#+begin_src emacs-lisp
  (require 'subr-x)
  (setq homebrew-plantuml-jar-path
        (expand-file-name (string-trim (shell-command-to-string "brew list plantuml | grep jar"))))

  (use-package plantuml-mode
    :custom
    (plantuml-jar-path homebrew-plantuml-jar-path))

  (use-package ob-plantuml
    :ensure nil
    :after org
    :custom
    (org-plantuml-jar-path homebrew-plantuml-jar-path))
#+end_src

Configure the languages for which to load org-babel support.

#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-config
(org-babel-do-load-languages 'org-babel-load-languages
                               '((emacs-lisp . t)
                                 (python . t)
                                 (ipython . t)
                                 (shell . t)
                                 (plantuml . t)))
#+end_src

This is potentially dangerous: it suppresses the query before executing code
from within org-mode. I set this because I only run source blocks that I've
written myself, and feel confident in the behaviour of.

#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-custom-vars
  (org-confirm-babel-evaluate nil)
#+end_src

Automatically show inline images, useful when executing code that produces them,
such as PlantUML or Graphviz.

#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-hooks
  (org-babel-after-execute . org-redisplay-inline-images)
#+end_src

This little snippet has revolutionized my literate programming workflow. It
automatically runs =org-babel-tangle= upon saving any org-mode buffer, which means
the resulting files will be automatically kept up to date.

#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-hooks
  (org-mode . (lambda () (add-hook 'after-save-hook 'org-babel-tangle
                                   'run-at-end 'only-in-org-mode)))
#+end_src

I add hooks to measure and report how long the tangling took.

#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-hooks
  (org-babel-pre-tangle  . (lambda ()
                             (setq sam/pre-tangle-time (current-time))))
  (org-babel-post-tangle . (lambda ()
                             (message "org-babel-tangle took %s"
                                             (format "%.2f seconds"
                                                     (float-time (time-since sam/pre-tangle-time))))))
#+end_src

*** Org-jira
My setup for org-jira has gotten a little bit complicated. I've added some
custom code to enable a hook that can update issue statuses when I change the
org TODO state. The hook is defined in the =use-package= block here, and the code
to get it all working is under the [[Linking Jira with local TODO states]] heading.
#+BEGIN_SRC emacs-lisp :noweb yes
(use-package org-jira
  :general
  <<org-jira-keybindings>>
  :custom
  <<org-jira-custom-vars>>
  :config
  <<org-jira-config>>
  :hook
  (org-after-todo-state-change . sam/org-jira-todo-hook))
#+END_SRC
**** Keybindings
#+BEGIN_SRC emacs-lisp
(spacemacs/declare-prefix "J" "jira")
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-jira-keybindings
(:prefix dotspacemacs-leader-key
 :states 'normal
         "Ji" 'org-jira-get-issues
         "Jp" 'org-jira-progress-issue-next
         "Jt" 'org-jira-progress-issue
         "Jr" 'org-jira-refresh-issues-in-buffer
         "Jc" 'org-jira-create-issue
         "Js" 'org-jira-create-subtask
         "Jj" 'org-jira-get-subtasks
         "Jk" 'org-jira-update-comment
         "Ju" 'org-jira-update-issue
         "Jw" 'org-jira-update-worklogs-from-org-clocks)
#+END_SRC
**** Organization specific definitions
Define the url and token for accessing the Rubikloud Jira organization.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-jira-custom-vars
(jiralib-url "https://rubikloud.atlassian.net")
(sam/jiralib-cookie (auth-source-pass-get 'secret "org/org-jira.el"))
(jiralib-token
    `("Cookie" . (sam/jiralib-cookie)))
#+END_SRC

Define the mapping between jira states used at Rubikloud and the appropriate org-mode TODO states.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-jira-custom-vars
(org-jira-jira-status-to-org-keyword-alist
 '(("Selected for Development" . "TODO")
   ("To Do" . "NEXT")
   ("In Progress" . "STARTED")
   ("In Review" . "WAITING")
   ("On Hold (Blocked)" . "HOLD")
   ("Done" . "DONE")))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-jira-custom-vars
(org-jira-working-dir "~/Dropbox/life")
#+END_SRC
**** Linking Jira with local TODO states
=org-jira= maps the jira status to the org keyword in the
=org-jira-jira-status-to-org-keyword-alist= variable. However, what we actually
need to know is the =action-id= for each =org-jira= state, so we can pass the
appropriate ID to the =org-jira-progress-issue-action= function. I think there is a way to
do this nicely with the already created mapping between jira status and org and
then setting the variable =jiralib-available-actions-cache=. The reason this
became complicated is because the mapping from jira status to org state is not
one to one. The project that the issue belongs to changes what action ID a state
maps to.

My solution to the above is a variable that defines the action ID to org mapping
for each Jira project I am involved in.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-jira-config
(defvar sam/org-jira-org-action-ids-alist
    '(("DS"
       ("21" . "TODO")
       ("31" . "STARTED")
       ("41" . "DONE")
       ("51" . "WAITING")
       ("61" . "TODO"))
      ("LCM"
       ("101" . "HOLD")
       ("111" . "DONE")
       ("81" . "TODO")
       ("41" . "WAITING")
       ("21" . "STARTED"))))
#+END_SRC

In the hook function we need to make sure that we're on an org-jira issue. This
macro is defined in the =org-jira= package but I couldn't figure out how to access
it, so I redefined it in my config.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-jira-config
(defmacro ensure-on-issue (&rest body)
    "Make sure we are on an issue heading, before executing BODY."
    (declare (debug t))
    (declare (indent 'defun))
    `(save-excursion
       (save-restriction
         (widen)
         (unless (looking-at "^\\*\\* ")
           (search-backward-regexp "^\\*\\* " nil t)) ; go to top heading
         (let ((org-jira-id (org-jira-id)))
           (unless (and org-jira-id (string-match (jiralib-get-issue-regexp) (downcase org-jira-id)))
             (error "Not on an issue region!")))
         ,@body)))
#+END_SRC

Finally we can define the hook function. After ensuring we're on the issue, we
get the heading element and extract the tags and the =todo-keyword=. We can
extract the project key from the tags and use it to select the correct action ID
from the previously defined mapping. Finally we call
=org-jira-progress-issue-action= with said ID.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-jira-config
(defun sam/org-jira-todo-hook ()
    "Progress issue workflow."
    (ensure-on-issue
     (org-back-to-heading t)
     (let* (
            (element (org-element-at-point))
            (tag (car (org-element-property :tags element)))
            (status (org-element-property :todo-keyword element))
            (proj-key (replace-regexp-in-string "_.*" "" tag))
            (action (car (rassoc status (cdr (assoc proj-key sam/org-jira-org-action-ids-alist))))))
       (message tag)
       (message proj-key)
       (message status)
       (message action)
       (org-jira-progress-issue-action action))))
#+END_SRC
** Tools
*** Company
With =company-mode=, we get automatic completion - when there are completions
available, a popup menu will appear when you stop typing for a moment, and you
can either continue typing or accept the completion using the Enter key. I
enable it globally.

#+begin_src emacs-lisp
  (use-package company
    :hook
    (after-init . global-company-mode))
#+end_src
*** Flycheck
#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :custom
  (flycheck-checker 'python-flake8)
  (flycheck-checker-error-threshold 900)
  (flycheck-emacs-lisp-load-path 'inherit)
  :hook
  (after-init . global-flycheck-mode))
#+END_SRC
*** Git
Trying out =git-gutter=
#+BEGIN_SRC emacs-lisp
(use-package git-gutter
  :config
  (global-git-gutter-mode 't))
#+END_SRC
*** Lsp-Mode
Note that this section is even more under development than everything else around it.

I am attempting to setup =lsp-mode= and the Microsoft python language server, per
[[https://vxlabs.com/2018/11/19/configuring-emacs-lsp-mode-and-microsofts-visual-studio-code-python-language-server/][this excellent blog post]].

First we need to setup =lsp-mode= and enable logging by setting =lsp-print-io= to =t=.
#+BEGIN_SRC emacs-lisp
(use-package lsp-mode
  :custom
  (lsp-print-io t)
  :config
  (require 'lsp-clients))
#+END_SRC

To handle the configuration of =lsp-mode= for talking with the MS language server,
I'm using [[https://github.com/andrew-christianson/lsp-python-ms][lsp-python-ms]]. It's just a packaged version of the code described in
the previously linked blog post.
#+BEGIN_SRC emacs-lisp
(use-package lsp-python-ms
  :hook (python-mode . lsp-python-enable)
  :config
  ;; for dev build of language server
  (setq lsp-python-ms-dir
        (expand-file-name "/usr/local/etc/python-language-server/output/bin/Release/")))
#+END_SRC
*** Projectile
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :custom
  (projectile-project-search-path '("~/rubikloud"))
)
#+END_SRC
*** Tramp
I was having a lot of issues with tramp + zsh on my remote machine, this was
part of the debugging I did then. I don't remember exactly why these things were
necessary though.
#+BEGIN_SRC emacs-lisp
(eval-after-load 'tramp '(setenv "SHELL" "/bin/bash"))
(setq tramp-default-method "ssh")
#+END_SRC
